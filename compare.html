<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Compare Patterns ‚Äì How AI Recognizes</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root {
      --bg: #f7f7f7;
      --card: #fff;
      --accent: #333;
    }

    body {
      font-family: 'Poppins', sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      background: var(--bg);
      margin: 0;
      padding: 18px;
      text-align: center;
    }

    h2 { color: #222; margin-bottom: 6px; }
    p { color: #555; max-width: 720px; margin-bottom: 14px; }

    /* Page layout: top row has image + numeric grid, bottom row has references */
    .grid-container {
      display: flex;
      flex-direction: column;
      gap: 18px;
      width: 100%;
      max-width: 980px;
      align-items: center;
    }

    .top-row {
      display: flex;
      gap: 20px;
      align-items: center;
      justify-content: center;
      width: 100%;
      flex-wrap: wrap;
    }

    /* small card for image+grid units */
    .card {
      background: var(--card);
      padding: 10px;
      border-radius: 8px;
      box-shadow: 0 6px 16px rgba(0,0,0,0.06);
    }

    /* Visual preview (image) */
    .visual {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }

    #visualCanvas {
      width: 160px; /* visual size on screen */
      height: 160px;
      image-rendering: pixelated; /* crisp pixels when scaled */
      border: 2px solid #ccc;
      background: #fff;
      display: block;
    }

    /* test numeric grid */
    .test-grid {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }

    /* bottom row: reference items aligned horizontally */
    .bottom-row {
      display: flex;
      gap: 22px;
      justify-content: center;
      width: 100%;
      /* allow horizontal scroll on very narrow screens */
      overflow-x: auto;
      padding-bottom: 6px;
    }

    .ref-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      padding: 6px;
      border-radius: 10px;
      transition: transform 0.22s ease, box-shadow 0.22s ease;
      min-width: 0;
    }

    /* highlight applied to the whole ref-item container so outline is complete */
    .ref-item.highlight {
      box-shadow: 0 0 18px 6px rgba(0, 184, 120, 0.35);
      transform: translateY(-4px) scale(1.03);
      border-radius: 12px;
    }

    /* table styling (compact) */
    table {
      border-collapse: collapse;
      background: white;
    }
    td {
      width: 22px;
      height: 22px;
      border: 1px solid #dcdcdc;
      font-size: 10px;
      text-align: center;
      background: white;
      padding: 0;
      box-sizing: border-box;
    }

    .label { font-weight: 600; margin-top: 4px; font-size: 14px; }

    .controls {
      margin-top: 12px;
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      justify-content: center;
    }

    button {
      padding: 10px 16px;
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 500;
    }
    button:hover { background: #555; }

    /* small-screen tweaks */
    @media (max-width: 720px) {
      #visualCanvas { width: 120px; height: 120px; }
      td { width: 18px; height: 18px; font-size: 9px; }
    }
  </style>
</head>
<body>
  <h2>ü§ñ How AI Recognizes a Letter</h2>
  <p>AI compares what it ‚Äúsees‚Äù with patterns it already knows. Can you guess which stored pattern matches this image best?</p>

  <div class="grid-container">

    <!-- TOP ROW: visual image (left) + numeric grid for new image (right) -->
    <div class="top-row">
      <div class="card visual" aria-hidden="false">
        <div style="font-weight:600">Image Preview</div>
        <!-- visual canvas: we'll draw a scaled-up image of the test pattern here -->
        <canvas id="visualCanvas" width="8" height="8"></canvas>
        <div style="font-size:13px;color:#444;">This is how the grid looks as an image</div>
      </div>

      <div class="card test-grid" id="testGridContainer">
        <div style="font-weight:600">üîç Numerical grid for New Image</div>
        <div id="testGrid"></div><!-- we append the table here -->
      </div>
    </div>

    <!-- BOTTOM ROW: reference patterns -->
    <div class="bottom-row" id="refRow"></div>

    <!-- Controls below -->
    <div class="controls">
      <button id="compareBtn">Compare</button>
      <button id="showAnotherBtn">Show Another</button>
      <button id="nextBtn">Next ‚Üí Now let's learn how AI sees this colorful world</button>
    </div>
  </div>

  <script>
    const gridSize = 8;

    // --- Simple grayscale matrices for 3 letters ---
    const patterns = {
      'A': [
        [255,200,100,100,100,100,200,255],
        [255,100,255,255,255,255,100,255],
        [100,255,255,255,255,255,255,100],
        [100,255,100,100,100,100,255,100],
        [100,255,100,255,255,100,255,100],
        [100,100,100,100,100,100,100,100],
        [100,255,100,255,255,100,255,100],
        [255,255,255,255,255,255,255,255],
      ],
      'B': [
        [100,100,100,100,100,255,255,255],
        [100,255,255,255,255,100,100,255],
        [100,255,255,255,255,100,100,255],
        [100,100,100,100,100,255,255,255],
        [100,255,255,255,255,100,100,255],
        [100,255,255,255,255,100,100,255],
        [100,100,100,100,100,255,255,255],
        [255,255,255,255,255,255,255,255],
      ],
      'C': [
        [255,200,100,100,100,200,255,255],
        [200,100,255,255,255,255,255,255],
        [100,255,255,255,255,255,255,255],
        [100,255,255,255,255,255,255,255],
        [100,255,255,255,255,255,255,255],
        [100,255,255,255,255,255,255,255],
        [200,100,255,255,255,255,255,255],
        [255,200,100,100,100,200,255,255],
      ]
    };

    const letters = Object.keys(patterns);
    let testLetterIndex = 0; // index among letters
    let testLetter = letters[testLetterIndex];

    const testGridContainer = document.getElementById('testGrid');
    const refsRow = document.getElementById('refRow');
    const visualCanvas = document.getElementById('visualCanvas');

    // make a table from a matrix
    function makeGridTable(matrix) {
      const table = document.createElement('table');
      for (let i = 0; i < gridSize; i++) {
        const tr = document.createElement('tr');
        for (let j = 0; j < gridSize; j++) {
          const td = document.createElement('td');
          const v = matrix[i][j];
          td.textContent = v;
          td.style.background = `rgb(${v},${v},${v})`;
          tr.appendChild(td);
        }
        table.appendChild(tr);
      }
      return table;
    }

    // draw visual canvas scaled from matrix (we use canvas width=8,height=8 but CSS scales it)
    function drawVisual(matrix) {
      const ctx = visualCanvas.getContext('2d');
      // set canvas internal size to gridSize so pixels map 1:1
      visualCanvas.width = gridSize;
      visualCanvas.height = gridSize;
      // draw pixels
      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          const v = matrix[i][j];
          ctx.fillStyle = `rgb(${v},${v},${v})`;
          ctx.fillRect(j, i, 1, 1);
        }
      }
      // keep display large by setting CSS width/height (already set in style) and use image-rendering:pixelated
    }

    // render test grid and refs
    function render() {
      const matrix = patterns[testLetter];
      // top visual + numeric grid
      testGridContainer.innerHTML = '';
      const table = makeGridTable(matrix);
      testGridContainer.appendChild(table);
      // draw image
      drawVisual(matrix);

      // bottom refs
      refsRow.innerHTML = '';
      letters.forEach((l, idx) => {
        const item = document.createElement('div');
        item.className = 'ref-item';
        item.dataset.index = idx;

        const grid = makeGridTable(patterns[l]);
        const label = document.createElement('div');
        label.className = 'label';
        label.textContent = `Letter ${l}`;

        item.appendChild(grid);
        item.appendChild(label);
        refsRow.appendChild(item);
      });
    }

    // compare and highlight best matching ref whole item
    function comparePatterns() {
      const test = patterns[testLetter];
      let bestIdx = -1, bestScore = -Infinity;

      letters.forEach((l, idx) => {
        const ref = patterns[l];
        let match = 0, total = gridSize * gridSize;
        for (let i = 0; i < gridSize; i++) {
          for (let j = 0; j < gridSize; j++) {
            const diff = Math.abs(test[i][j] - ref[i][j]);
            if (diff < 80) match++;
          }
        }
        const score = match / total;
        if (score > bestScore) { bestScore = score; bestIdx = idx; }
      });

      // apply highlight to the matching .ref-item container (so outline is complete)
      const items = refsRow.querySelectorAll('.ref-item');
      items.forEach((it, i) => {
        if (i === bestIdx) it.classList.add('highlight'); else it.classList.remove('highlight');
      });
    }

    function showAnother() {
      // rotate to next letter
      testLetterIndex = (testLetterIndex + 1) % letters.length;
      testLetter = letters[testLetterIndex];
      // clear any highlights
      const items = refsRow.querySelectorAll('.ref-item');
      items.forEach(it => it.classList.remove('highlight'));
      render();
    }

    // wire up buttons
    document.getElementById('compareBtn').addEventListener('click', comparePatterns);
    document.getElementById('showAnotherBtn').addEventListener('click', showAnother);
    document.getElementById('nextBtn').addEventListener('click', () => {
      window.location.href = 'color_grid.html';
    });

    // initial render
    render();
  </script>
</body>
</html>
